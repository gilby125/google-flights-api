# Worker deployment with Tailscale sidecar
# =========================================
# This connects workers to your main server via Tailscale mesh VPN
# No need to expose PostgreSQL/Redis to the public internet!
#
# Prerequisites:
#   1. Tailscale installed on main server
#   2. Get your Tailscale auth key from: https://login.tailscale.com/admin/settings/keys
#   3. Set TS_AUTHKEY in .env.worker
#
# Usage:
#   docker compose -f docker-compose.worker.tailscale.yml up -d

services:
  # Tailscale sidecar - provides VPN connectivity
  tailscale:
    image: tailscale/tailscale:latest
    hostname: ${WORKER_ID:-worker-1}
    environment:
      - TS_AUTHKEY=${TS_AUTHKEY:?Tailscale auth key required}
      - TS_STATE_DIR=/var/lib/tailscale
      - TS_USERSPACE=true
      - TS_SOCKS5_SERVER=localhost:1055
      - TS_OUTBOUND_HTTP_PROXY_LISTEN=localhost:1055
    volumes:
      - tailscale-state:/var/lib/tailscale
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    restart: unless-stopped

  worker:
    image: ghcr.io/gilby125/flight-api:${IMAGE_TAG:-latest}
    network_mode: "service:tailscale" # Share network namespace with Tailscale
    depends_on:
      - tailscale
    environment:
      # Worker identification
      WORKER_ID: ${WORKER_ID:-worker-1}

      # Core settings
      PORT: 8080
      ENVIRONMENT: ${ENVIRONMENT:-production}
      API_ENABLED: "false"
      WORKER_ENABLED: "true"
      INIT_SCHEMA: "false"
      SEED_NEO4J: "false"
      NEO4J_ENABLED: ${NEO4J_ENABLED:-false}

      # Worker pool settings
      WORKER_CONCURRENCY: ${WORKER_CONCURRENCY:-4}
      WORKER_JOB_TIMEOUT: ${WORKER_JOB_TIMEOUT:-10m}
      WORKER_MAX_RETRIES: ${WORKER_MAX_RETRIES:-3}

      # =========================================
      # Use Tailscale IPs for internal services!
      # =========================================
      # Find your main server's Tailscale IP: tailscale ip -4
      # Or use MagicDNS hostname if enabled

      # PostgreSQL via Tailscale
      DB_HOST: ${TS_MAIN_SERVER_IP:?Set main server Tailscale IP}
      DB_PORT: ${DB_PORT:-5432}
      DB_USER: ${DB_USER:-flights}
      DB_PASSWORD: ${DB_PASSWORD:?DB_PASSWORD is required}
      DB_NAME: ${DB_NAME:-flights}
      DB_SSLMODE: ${DB_SSLMODE:-disable} # Tailscale encrypts, SSL optional
      DB_REQUIRE_SSL: "false"

      # Redis via Tailscale
      REDIS_HOST: ${TS_MAIN_SERVER_IP}
      REDIS_PORT: ${REDIS_PORT:-6379}
      REDIS_PASSWORD: ${REDIS_PASSWORD:?REDIS_PASSWORD is required}
      REDIS_QUEUE_GROUP: ${REDIS_QUEUE_GROUP:-flights_workers}
      REDIS_QUEUE_STREAM_PREFIX: ${REDIS_QUEUE_STREAM_PREFIX:-flights}

      # Neo4j via Tailscale (optional)
      NEO4J_URI: bolt://${TS_MAIN_SERVER_IP}:7687
      NEO4J_USER: ${NEO4J_USER:-neo4j}
      NEO4J_PASSWORD: ${NEO4J_PASSWORD:-}

      # Scheduler leader election
      SCHEDULER_LOCK_KEY: ${SCHEDULER_LOCK_KEY:-scheduler:leader}
      SCHEDULER_LOCK_TTL: ${SCHEDULER_LOCK_TTL:-30s}
      SCHEDULER_LOCK_RENEW: ${SCHEDULER_LOCK_RENEW:-10s}

      # Logging
      LOG_LEVEL: ${LOG_LEVEL:-info}
      LOG_FORMAT: ${LOG_FORMAT:-json}

    # Wait for Tailscale to connect before starting
    command: >
      sh -c "
        echo 'Waiting for Tailscale connection...'
        until ping -c 1 ${TS_MAIN_SERVER_IP} > /dev/null 2>&1; do
          echo 'Waiting for Tailscale VPN...'
          sleep 2
        done
        echo 'Tailscale connected! Starting worker...'
        exec /app/flight-api
      "

    restart: unless-stopped

    deploy:
      resources:
        limits:
          cpus: ${WORKER_CPU_LIMIT:-1.0}
          memory: ${WORKER_MEM_LIMIT:-1G}

    healthcheck:
      # Worker deployments often run with API_ENABLED=false, so HTTP health may not exist.
      test: [ "CMD-SHELL", "pgrep -f '/app/flight-api' >/dev/null 2>&1" ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  tailscale-state:
