name: CI/CD Pipeline
on:
  push:
    branches: [ main, price-graph-sweep, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '6 0 * * 5'

env:
  GO_VERSION: '1.24'
  DOCKER_IMAGE: ghcr.io/${{ github.repository_owner }}/flight-api
  ENABLE_INTEGRATION_TESTS: ${{ vars.ENABLE_INTEGRATION_TESTS || '0' }}
  ENABLE_WORKER_TESTS: ${{ vars.ENABLE_WORKER_TESTS || '0' }}

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Build
      run: go build ./...

    - name: Run tests
      run: |
        go test -p 4 -coverprofile=coverage.out ./...
        go tool cover -html=coverage.out -o coverage.html

    - name: Check for vulnerabilities
      run: |
        go list -m all
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...

  run-examples:
    runs-on: ubuntu-latest
    needs: build-test
    if: ${{ (vars.ENABLE_INTEGRATION_TESTS || '0') == '1' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Run example1
      run: go run ./examples/example1/main.go

    - name: Run example2
      run: go run ./examples/example2/main.go

    - name: Run example3
      run: go run ./examples/example3/main.go

  iata:
    runs-on: ubuntu-latest
    needs: build-test
    if: ${{ (vars.ENABLE_INTEGRATION_TESTS || '0') == '1' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Generate IATA
      run: go run ./iata/generate/generate.go

    - name: Check for changes
      run: git diff

  proto:
    runs-on: ubuntu-latest
    needs: build-test
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Setup protocol buffer compiler
      env:
        PROTOC_VERSION: 3.12.4
      run: |
        curl -sSL -o protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v${PROTOC_VERSION}/protoc-${PROTOC_VERSION}-linux-x86_64.zip
        unzip -o protoc.zip -d "${HOME}/.local"
        rm protoc.zip
        echo "${HOME}/.local/bin" >> "${GITHUB_PATH}"
        go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.31.0

    - name: Generate proto
      run: go generate ./...

    - name: Check for changes
      run: |
        if [ ! -z "$(git status --porcelain)" ]
        then
          git diff
          exit 1
        fi

  docker-build:
    runs-on: ubuntu-latest
    needs: build-test
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to GHCR
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Compute Docker image tags
      id: meta
      run: |
        BRANCH="${GITHUB_REF_NAME}"
        TAGS="${DOCKER_IMAGE}:${BRANCH}
${DOCKER_IMAGE}:${GITHUB_SHA}"
        if [ "${BRANCH}" = "main" ]; then
          TAGS="${TAGS}
${DOCKER_IMAGE}:latest"
        fi
        {
          echo "tags<<EOF"
          echo "${TAGS}"
          echo "EOF"
        } >> "${GITHUB_OUTPUT}"

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        # No build args needed for pre-generated certs
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-kubernetes-staging:
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: ${{ github.event_name == 'push' && github.ref_name == 'main' && (vars.ENABLE_K8S_DEPLOY || '0') == '1' }}
    permissions:
      contents: read
      deployments: write
    environment: staging
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure Kubernetes
      uses: azure/setup-kubectl@v3
      with:
        version: '1.27.3'

    - name: Deploy to Staging
      working-directory: kubernetes/manifests/staging
      run: |
        echo "${{ secrets.KUBECONFIG_DATA }}" | base64 -d > ${HOME}/.kube/config
        kubectl apply -k .
        kubectl rollout status deployment/flight-api-staging

  performance-test:
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes-staging]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Install hey
      run: go install github.com/rakyll/hey@latest

    - name: Run performance tests
      env:
        KUBECONFIG: ${{ secrets.KUBECONFIG_DATA }}
      run: |
        echo "Starting performance tests against staging..."
        mkdir -p $HOME/.kube
        echo "$KUBECONFIG" | base64 -d > $HOME/.kube/config
        
        STAGING_URL=$(kubectl get svc flight-api-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        echo "Testing health endpoint:"
        hey -n 1000 -c 50 http://$STAGING_URL:8080/healthz
        
        echo "Testing search endpoint:"
        hey -n 5000 -c 100 -m POST \
          -T "application/json" \
          -D test/load/search_payload.json \
          http://$STAGING_URL:8080/api/v1/search
        
        echo "Verifying latency thresholds:"
        if ! hey -n 1000 -c 50 http://$STAGING_URL:8080/healthz | grep -q '95% in 500ms'; then
          echo "Performance threshold exceeded!"
          exit 1
        fi

  deploy-swarm:
    runs-on: ubuntu-latest
    needs: [deploy-kubernetes-staging, performance-test]
    if: github.event_name == 'push' && github.ref_name == 'main'
    steps:
    - name: Deploy to Docker Swarm
      uses: appleboy/ssh-action@v1
      with:
        host: ${{ secrets.SWARM_MANAGER }}
        username: ${{ secrets.SWARM_USER }}
        key: ${{ secrets.SWARM_SSH_KEY }}
        script: |
          # Capture current running version
          PREV_IMAGE=$(docker service inspect --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' flight-api_web)
          echo "PREV_IMAGE=${PREV_IMAGE}" >> $GITHUB_ENV
          
          # Deploy new version
          docker stack deploy \
            --with-registry-auth \
            -c docker-compose.prod.yml \
            flight-api
          
          # Verify deployment health
          MAX_RETRIES=3
          RETRY_DELAY=30
          for i in $(seq 1 $MAX_RETRIES); do
            if docker service inspect --format '{{.UpdateStatus.State}}' flight-api_web | grep -q "completed"; then
              echo "Deployment verified healthy"
              exit 0
            fi
            echo "Waiting for healthy deployment (attempt $i/$MAX_RETRIES)"
            sleep $RETRY_DELAY
          done
          
          # Rollback if verification fails
          echo "Deployment failed - rolling back to ${PREV_IMAGE}"
          docker service update \
            --image ${PREV_IMAGE} \
            --rollback-parallelism 1 \
            --update-delay 30s \
            flight-api_web
          exit 1
